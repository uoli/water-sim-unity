// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeDensityAndPressure
#pragma kernel ComputePressureForce
#pragma kernel ComputePositionFromVelocityAndHandleCollision

static const float PI = 3.1415926535897932384626433;


RWStructuredBuffer<float> Positions;
RWStructuredBuffer<float> Densities;
RWStructuredBuffer<float> Pressure;
RWStructuredBuffer<float> Velocity;
RWStructuredBuffer<float> DebugBuff;
float ParticleCount;
float Width;
float Height;
float Mass;
float TargetDensity;
float PressureMultiplier;
float SmoothingRadius;
float SquaredSmoothingRadius;
float DeltaTime;
float BoundaryPushStrength;
float CollisionDamping;

//TODO: this can be calculated once outside the shader
float CalcSmoothingKernel2Factor(float smoothingRadius)
{
    return 6 / (PI * pow(smoothingRadius, 4));
}

float SmoothingKernel2(float dst, float radius, float preCalculatedFactor)
{
    if (dst >= radius) return 0;
    float dif = radius - dst;
    return dif * dif * preCalculatedFactor; 
}

float CalculateDensity(int particleIndex, float precalculatedKernelFactor)
{
    //var particleIndices = new NativeList<int>(positions.Length, Allocator.Temp);
    //lookup.GetParticlesAround(pos, particleIndices);
    float2 pos = float2(Positions[particleIndex*2], Positions[particleIndex*2 + 1]);

        
    float density = 0;
    for (int i = 0; i < ParticleCount; i++)
    {
        float2 position = float2(Positions[i*2], Positions[i*2 + 1]);
        float2 diff = position - pos;
        float sqrDst = dot(diff,diff);
        sqrDst = max(sqrDst, 0.0);
        if (sqrDst > SquaredSmoothingRadius) continue;
        //var influence = SmoothingKernel(sqrDst, squaredSmoothingLength, kernelTerm);
        float influence = SmoothingKernel2(sqrt(sqrDst), SmoothingRadius, precalculatedKernelFactor);
        density += Mass * influence;
    }
    return density;
}

[numthreads(64,1,1)]
void ComputeDensityAndPressure (uint3 id : SV_DispatchThreadID)
{
    int index = id.x;
    if (index >= ParticleCount) return;
    
    //float area = Width * Height;
    //float particlePerArea = area / ParticleCount;
    float y =  index / Height;
    float x =  index % Width;

    // Positions[id.x*2] = x;
    // Positions[id.x*2 + 1] = y;

    float precalculatedKernelFactor = CalcSmoothingKernel2Factor(SmoothingRadius);
    float density = CalculateDensity(index, precalculatedKernelFactor);
    
    float densityError = density - TargetDensity;
    float pressure = densityError * PressureMultiplier;

    Densities[index] = density;
    Pressure[index] = pressure;
}

float SmoothingKernel2Derivative(float dst, float radius)
{
    if (dst >= radius) return 0;

    float scalingFactor = 12 / (pow(radius, 4) * PI); //TODO: this can be calculated once outside the shader
    float dif = radius - dst;

    return -dif * scalingFactor;
}

const float EPSILON = 1e-6;

float Hash11(float x) //random
{
    x = frac(x * 0.1031);
    x *= x + 33.33;
    x *= x + x;
    return frac(x);
}

float2 RandomUnitVector2D(uint seed)
{
    float angle = Hash11(seed) * PI * 2;
    return float2(cos(angle), sin(angle));
}

float2 CalculatePressureGradient(int i) {
    // var particleIndices = new NativeList<int>(position.Length, Allocator.Temp);
    // lookup.GetParticlesAround(position[i], particleIndices);
    float2 pressureGradient = 0;
    float2 selfPos = float2(Positions[i*2], Positions[i*2 + 1]);
    for (int j = 0; j < ParticleCount; j++)
    {
        if (i == j) continue;
        float2 neighbourPos = float2(Positions[j*2], Positions[j*2 + 1]);
        float2 dif = neighbourPos - selfPos; 
        float sqrDst = dot(dif,dif);
        if (sqrDst > SquaredSmoothingRadius) continue;

        float distance = sqrt(sqrDst);
        if (distance < 0.000001 || isnan(distance) ) 
        {
            //points are too close we get numerical errors
            //so calculate a random direction really close by.
            //Not sure about the effects on newtons 3rd law and symmetry
            //DebugBuff[i]+=6000;
            dif = RandomUnitVector2D(selfPos.x) * 0.000001;
            distance = sqrt(dot(dif,dif));
        }
        float2 dir = dif/distance;
        //var influence = SmoothingKernelDerivative(distance, sqrDst, squaredSmoothingLength, kernelDerivativeTerm);
        float influence = SmoothingKernel2Derivative(distance, SmoothingRadius);
        float averagedPressure = (Pressure[j] + Pressure[i]) / 2;
        pressureGradient += dir * (averagedPressure * Mass) / Densities[j] * influence;
    }
    return pressureGradient;
}

[numthreads(64,1,1)]
void ComputePressureForce (uint3 id : SV_DispatchThreadID)
{
    int index = id.x;
    
    float density = Densities[index]; 
    float2 pressureForce = CalculatePressureGradient(index);
    float2 pressureAcceleration = pressureForce / density;
    float2 velocity = pressureAcceleration * DeltaTime;
    
    Velocity[index * 2] += velocity.x;
    Velocity[index * 2 + 1] += velocity.y;
}

[numthreads(64,1,1)]
void ComputePositionFromVelocityAndHandleCollision(uint3 id : SV_DispatchThreadID)
{
    int index = id.x;

    float2 position = float2(Positions[index*2], Positions[index*2 + 1]);
    float2 velocity = float2(Velocity[index*2], Velocity[index*2 + 1]);
    position += velocity * DeltaTime;
            
    if (position.x < SmoothingRadius)
    {
        float strength = (SmoothingRadius - position.x) / SmoothingRadius;
        velocity.x += BoundaryPushStrength * strength * DeltaTime;
        if (position.x < 0) {
            position.x = -position.x;
            velocity.x *= -CollisionDamping;
        }
    }
    if (position.y < SmoothingRadius)
    {
        float strength = (SmoothingRadius - position.y) / SmoothingRadius;
        velocity.y += BoundaryPushStrength * strength * DeltaTime;
        if (position.y < 0)
        {
            position.y = - position.y;
            velocity.y *= -CollisionDamping;
        }
    }

    float distToRightWall = abs(Width - position.x);
    if (distToRightWall < SmoothingRadius)
    {
        float strength = (SmoothingRadius - distToRightWall) / SmoothingRadius;
        velocity.x -= BoundaryPushStrength * strength * DeltaTime;
        if (position.x > Width)
        {
            position.x = Width - (position.x-Width);
            velocity.x *= -CollisionDamping;
        }
    }
    float distToBottomWall = abs(Height - position.y);
    if (distToBottomWall < SmoothingRadius)
    {
        float strength = (SmoothingRadius - distToBottomWall) / SmoothingRadius;
        velocity.y -= BoundaryPushStrength * strength * DeltaTime;
        if (position.y > Height)
        {
            position.y = Height;
            velocity.y *= -CollisionDamping;
        }
    }
    Positions[index*2] = position.x;
    Positions[index*2+1] = position.y;
    Velocity[index*2] = velocity.x;
    Velocity[index*2+1] = velocity.y;
}